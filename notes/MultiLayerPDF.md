% 类似 DjVu 的多层压缩的 PDF 文件设计
% 张鹏程
% 2015-12-26

# 缘起

2015年12月26日, 在群里聊了关于 DjVu 的问题, 又引起了我对扫描图书的兴趣. 我个人是非常喜欢扫描版的电子书的. 而且这一天我也尝试了使用 Fine Reader 把一本扫描版的电子书进行 OCR 识别. 但结果并不理想. 在粗略了解了 DjVu 的一些技术原理以后, 加上文章作者对 PDF 特性的一些
提点, 我觉得构建一套高清晰的扫描版 PDF 文档是完全可能的. 所以就写下这篇文档来记述一下. 虽然我现在可能没有时间来实现.

# DjVu 的原理

为什么 DjVu 能够实现高清晰度同时高压缩比呢? [这篇文章](http://www.cnblogs.com/stronghorse/p/4913393.html) 给出了较为详细的描述.
DjVu 的核心就是: 将图像内容分层存储, 针对每一层的特点, 选择最合适的图像格式. DjVu 本身应该算做一种图像格式. 他把扫描图书的图像分成 3 层, 分别是: a) 背景层, b) 前景层 和 c) 蒙板层.

背景层存储了图书的背景, 插图等内容. DjVu 假设书里的背景和插图都不是人们重点关注的东西, 可以不用存那么清晰的图像, 所以通常使用比原始图像小
的图片来保存背景图片, 这样就显著减少了文件的体积. 不过, 如果背景里有插图的话, 就会显得模糊, 因为是缩放来的.

以后补充吧......

# 对扫描版 PDF 的设想

结合 DjVu 的分层模型, 甚至是 MRC（Mixed Raster Content，参见ISO/IEC 16485）模型, 以及关于视频压缩的一些知识, 设想了这样一种扫描的 PDF 文件结构:

1. 将扫描图像拆解成不同的层, 每个层尽可能的简单, 最好是单色, 不是单色, 也最好是可以用调色板表示的颜色, 保存成 PNG 格式.
2. 最地底层最好是纯色, 这样可以变更背景色. 但对于复杂的图像 (背景色覆盖率比较小的) 可以使用带有调色板的图像.
3. 层和层之间按照 PDF 的透明图像模型来组织, 这样所有的图层盖在一起的时候, 就还原出原始的图像了.

图像压缩的原理, 通过寻找相邻帧里的相似部分, 来显著减少需要保存的数据. 而扫描图书是静态的图像, 没有相邻的帧可以参考. 不过如果通过统计的方法, 对图像进行分析, 每次抽取占比最多的几个颜色作为底层,
上层再此抽取, 直到可以分离成简单的图元进行保存. 这里需要对 PDF 文件的图像模型, 以及透明图像模型进行深入的了解. 至于是否考虑保存成 bitmap 字体, 要综合考虑最后渲染的需要, 也许不保存成嵌入字体
更方便最后的生成, 因为都是在页面的某个位置引用一个图元, 区别只是图元保存的方式而已. 另外, 对于小的图元, 可以考虑使用其他的压缩方式, 比如 CCITT 或者 RLE, 具体要看哪种压缩结果更好, 可以每一种
都尝试压缩一下, 最后对比结果.

这种逐层压缩的方法, 局限就在于不能保存色彩相当丰富的图片类图书, 那些还是直接保存成 JPEG 2000 比较合适.

在研究的过程中, 发现 ABBYY 的 FineReader 支持一种教 MRC PDF 的格式, 可以先尝试一下.

# 探索1: OpenCV 抓取图像

为了降低成本, 最好的方式就是使用大家都有的, 或者价格便宜的硬件来实现采集, 后续的处理任务多用软件处理. 所以想到比较便宜的高拍仪或者高清摄像头. 高拍仪可能受限于其使用的软件, 不过其本身提供了基本的
二值化, 纠偏等功能, 而如果使用高清摄像头, 这些东西都还需要自己编写. 基于广泛使用的 OpenCV 视觉处理库, 很容易得到对应的算法, 而且 OpenCV 在操作图像的时候所使用的 Mat 模型也很方便. OpenCV 内置
了通过摄像头采集图像的功能, 但是为了下一步进行超分辨处理, 这里还需要获得同一张图片的多个曝光版本, 这就需要控制摄像头的光圈或者曝光时间等参数. 这个阶段也不需要单独购买摄像头, 只要用电脑自带的摄像头
配合 pyopencv 就可以进行实验了. 实验目标:

1. 通过 OpenCV 采集图像
2. 通过 OpenCV 改变 ISO_SPEED, EXPOSURE 等参数, 得到同一张图像的不同光场信息

# 探索2: 超分辨率算法

OpenCV 内置了一个超分辨算法, 利用上面获取的多帧图像, 通过 OpenCV 的算法来获得更高质量的原始图. A4 纸面, 21 cm x 29.7 cm 300 dpi 像素 2480 x 3508, 约 870 万像素. 普通的摄像头都是 500 万
像素, 所以需要达到 6 倍分辨率, 约 3000 万像素, 才能达到 600 dpi 的效果. 这里需要了解 OpenCV 的算法原理以及达到如此高分辨率所需要的原始图像帧数.

# 探索3: 预处理

考虑到后续处理的问题, 这里需要对原始图像进行纠偏, 纯色化, 降噪等操作. 具体需要看各种图像处理的算法以及 OpenCV 内置的可能的算法.

1. 纠偏是基本的需求, 因为拍摄的过程中, 难免出现摆放不正. 纠偏的依据主要是文字的方向. 具体算法还是需要查找相关的文献和书籍.
2. 纠偏以后, 需要裁边, 就是把图像放在一个尽可能大的矩形区域内. 裁边可能带来的复杂度就是, 裁边以后的图像大小可能会出现不同, 而贸然缩放各个图像, 则会造成图元识别的时候, 无法进行匹配. 所以要尽量避免复杂的处理.
3. 降噪可能是不太必须的操作, 但也要看一下中间结果的噪音有多大.
4. 最后是纯色化. 这一步和背景提取很像 所以可以合并到背景提取里.

# 探索4: 背景的提取

背景提取, 就是用有限的颜色来取代复杂的背景图像. 目前想到的算法就是统计颜色出现的频率, 如果可以统计颜色的分布, 那就更好了. 总之就是出现次数做多, 分布最广的那种颜色. 当然, 如果是黑白的, 那就是白色, 如果是灰色的,
则应该用比较浅的颜色, 如果是彩色的, 可能比较难办, 需要尝试一下看看会怎么样.

# 探索: 图元的提取

所谓图元, 就是构成整个页面的某个小的, 可以独立重复出现的部分. 图元不能太小, 因为最后在页面中还要描述其坐标, 以及有一个 ID. 如果太小, 则这些描述信息反而会让文件更大. 图元的发现也需要综合使用各种变换, 不要直接在
空间域中搜索, 那样必然会很慢. 图元要提取他的大小, 位置以及整体的数据信息.

# 探索: PDF 生成

最后, 将图元, 背景分层放入一个 PDF 中, 就可以做成一个类似 DjVu 的 PDF 文件了. 


