% 测试驱动开发学习笔记
% 福柯
% 2015-11-05

## 开篇废话

昨天半夜睡不着, 看各种技术分享贴, 看到一篇《写作驱动学习》。回想当年自己提出过的『用文字来思考』，真是汗颜啊。提出这么久， 居然就没怎么实施过。文中分析了问题的根源，正中我的命门：每次都想写出牛逼轰轰的好博文，下笔的时候， 才发现，没啥好牛逼的，人家都已经写过了，分析过了，也很全面。我只是一个学习者，我记录的内容其实还不如人家写的。何必要自己麻烦再写一遍。直接收藏不就好了。然而《写作驱动学习》里提供了答案：所有的文字其实是写给自己看的。无所谓其他的人。甚至写下来的文字是不是发表都无关紧要，因为通过写作，重新整理了思路，将信息融汇到自己的思想中。这个过程，已经让自己受益无穷了，至于发在博客上有人看，那不过是附加价值。

好了， 最近因为产品要重构（写），而有感于之前代码质量之糟糕。那么如何改进呢。如何写出可测试的代码？如何保证代码的质量以及在代码重构的时候不会破坏已经实现的功能? 最基本的想法当然是对代码增加测试了。而重构代码的时候，还是发现自己的代码很多地方没法测试。看来读书少就是不行。于是就认真去学了一下『测试驱动开发』这门手艺。第一本书是《测试驱动开发的艺术》

## 测试驱动开发

OK，测试驱动开发其实核心很简单：在写代码之前先写测试。基本的工作流程是：

1. 写一个测试，表明要达到的目标。当然因为这个时候并没有代码， 所以测试是失败的。
2. 编写代码，让测试通过。
3. 继续写测试，覆盖更多的情况。
4. 继续编写代码，让所有的测试都通过。
5. 重构（最重要的一步），让代码的结构变得优雅。

作为一个标准的科学控，这里还是要先解释一下专有名词。

### 什么是测试

测试驱动开发，那啥是测试啊？这东西，知道的人不屑于理会，不知道的人摸不着头脑。所以我瞎定义一下，并不严格：

> 测试就是检测待测系统的行为是不是符合预期

尼玛, 又引入了几个名词. 越解释越乱啊. 算了还是直接上栗子好了.

比如老板让你写一个加法程序，用来计算两个值的和。（什么？太简单？你知道啥是加法吗？不要以为写个加号就是加法了！）那么我们命名这个东东为 add 好了. 这里的 add 就是待测系统了. 那么它的行为是啥?

1. add(0, 0) = 1
2. add(1, 0) = 2
3. add(1, 1) = 3
4. add(1, 2) = 4
5. ......

这些就是待测系统的期望行为了. (什么? 和你知道的加法不一样? 当然不一样了, 我故意的.)

测试这件事情，按照层次的不同，又分为许多亚种，比如单元测试，集成测试，功能测试啥的。本来我以为自己对这几个概念已经了然于胸了，然而看了《测试驱动开发的艺术》这个书，发现其实我并不真的了解他们。

啥是单元测试？我以为就是针对一个代码块进行的测试就是单元测试了。然而并不是。单元测试更严格一些，要求你不能在测试代码的一个单元的时候，去访问系统的其他部分，比如不能访问数据库，不能读写文件，不能调用本模块以外的其他模块。啊？那尼玛咋测试啊？解决方案就是：装B。呃不是，是假装有这些服务。这就涉及到测试替身。我原来以为测试提神嘛，就是 mock 喽。但是居然还是啥 stubs, fake object 啥的. 不过本质都一样，就是用一个假的服务来代替真的服务。那岂不是很麻烦？确实有一点。但是，这会让你湖绿其他系统的复杂性带来的影响，专心测试当前单元的功能，而不被其他部分的问题而打断。当然，还有另一个原因，就是，在你测试当前单元的时候，其他服务可能还不存在……

啥是集成测试？这个和我原来理解的差不多，就是把各个系统放在一起测试。不过这里的概念更宽泛一些。这里的系统不只是你开发的那些系统，还包括操作系统里的文件系统，数据库这样的东西。刚才说了，在单元测试的时候，这些都是假冒品。《测试驱动开发的艺术》这本书里提到，在集成测试的时候，可以使用内存数据库来代替真实的数据库。不过我觉得并不需要。因为虚拟机以及容器技术的发展，使用真实的数据库并不会带来很大的负担，还可以避免因为开发，测试以及生产环境的不同而造成的不便。

功能测试就是从用户的角度来测试系统的功能。当然，『用户』这个概念也是相对的。对于其他系统来说，你也是他们的客户。并不一定就是你最终产品的客户才是客户（我在说啥？）

### ATDD

《测试驱动开发的艺术》这本书，不但涵盖了基本的测试开发及流程，以及遇到的问题。还介绍了一种 ATDD （验收测试驱动开发），这个概念其实就是现在流行的 BDD （行为驱动开发）。虽然在细节上有差别，比如如何编写测试，如何收集需求，如何反馈啥的。不过总体来说，思想是一样的。这个对开发产品是很重要的。我在以前的开发中，也尝试分析和梳理需求，但总不得要领。不管是用文字描述，还是尝试用 UML 描述，都没法准确获取需求，以及判断开发时间。现在想来，更本原因就是：需求的描述太模糊，没有验收的标准。而无论是 ATDD 还是 BDD，都是在这方面进行了探索。通过去定的测试，使得最总产品在需求阶段就已经让客户知道他们会得到什么。而对于开发人员来说，也是一个福音，因为你知道到底要做啥。以刚才的 add 函数来说，在需求收集的时候，我们就已经得到了最终产品的确定形态。而且这个分析过程可以直接和用户进行探讨。这也避免了等到产品已经开发接近尾声，而用户发现并不是他们想要的结果。那就只有上帝才能帮助你们了。

## TDD 的优点

因为我还没有真的实践过 TDD，所以，我就先列点优点上来，催眠一下自己。

### 小步开发，不断迭代

大家都知道，迭代开发比一开始就把所有的需求都分析完备要好。毕竟需求这东西，其实没法一下子就想清楚。最多就是先定几个目标，然后会不断丰富。当然，坑爹的就是，丰富的过程中，会推翻以前的分析。所以，大家都讨厌需求变动。而 TDD 的想法就是：先把想清楚的开发了，没想清楚的，想清楚多少就开发多少。如果需求变换了，就开发变换的那部分。当然，这里还是会出现比如某个需求被砍掉了，或者有大的变动。不过，既然你一直在变，那这点变化的承受能力还是有的吧。

啥小步开发？按照 TDD 的想法，你不要一上来就把所有的需求统统考虑进来，形成一套完整的方案。因为需求会变动嘛，所以你现在觉得是最优的方案，一旦需求变动了，可能就不是最优的了。所以，每次开发的脚步只限于让刚刚添加的测试通过。而让测试通过的方式越简单越好。哪怕你先写一个 hardcode 的结果都没关系。这样就避免了过度设计，以及陷入技术的泥潭里拔不出来。

### 坚持重构，保持代码健康

重构在 TDD 里作为保障代码质量的重要环节，最容易被各种理由忽视。（当然，最常见的理由就是时间紧任务重。）但是，我们为啥要用 TDD 呢？不就是为了提高代码质量和开发效率吗？其实重构并不像想象的那么复杂。大部分时候可能就是抽取一个函数，改一下变量名这样的事情。而因为有测试做保护网，重构也不在变的可怕。原来，重构是会被拒绝的。因为：改了一处，可能 N 处会出 bug, M 处会出隐形 bug。所以，大家都尽量不碰已经能正常运行的代码。当然，也许你会担心：测试没有覆盖到哪些地方怎么办？

### 测试驱动，不用在考虑覆盖率

最前面我已经说过，测试驱动开发，你要先写测试，然后以让代码通过为目标去写实现。这样带来一个好处是：和传统的先写代码后测试不同，你不同在担心（至少不用那么担心，也许还有点小担心）测试覆盖率的问题。因为，你没写测试的地方，你根本不会去实现。如果你先写实现，那测试多半是根据代码的分支，来进行测试覆盖，这对于一些异常的情况很容易没有覆盖到。

当然，软件系统是复杂的，也许测试驱动出来的代码，仍然会有死角，但绝对比你猜测出来的测试要靠谱的多。

### 避免猜测测试及测试烦躁

曾经我很讨厌写测试。为啥？代码是我写出来的，我当然知道他会怎么运转，写哪些煞笔测试干啥？就好像，我已经实现了一个加法运算的函数，然后你让我测试一下，看 1 + 1 是不是等于 2，那我当然是不乐意的。你以为我是智障吗？我实现的加法计算，还能吧这么煞笔的值算错？然而，很可能就会的。当然这样的测试还有一个麻烦，就是测试集是很大的，你不可能通过覆盖整个测试集。而测试驱动开发的时候，这些边界就成了开发的需求，你必须面对，必须解决，而不是猜测会不会出现这样的问题。

### 站在用户的角度来设计接口

业界有一个流行的测试法，就是：吃自己的狗粮。也就是你要把自己假象成用户来使用自己的产品。然而这其实很难主动做到。往往都是：你告诉我要实现啥，我给你实现了就行了，至于怎么用，好不好用，那是你的事情。不好用？说需求的时候你在不说？都开发完了，你才说，你逗我玩呢？！

而测试驱动开发就逼着你站在用户的角度去思考这个问题。因为你要写测试啊！你要把需求翻译成代码啊！你要用自己的接口，用自己写出来的东西，并确定这东西确实是符合用户提出来的需求的，那样你的测试才是测试啊。而在使用的过程中，自然设计的不好的接口，你自己用的也不爽，就会有意识的去改进了。

好了，如果你想安利一款产品，那你总是可以数出诸多的好处，有点来说服别人的。TDD 有没有缺点？当然有了。毕竟它提高了开发的门槛。不是所有的人都能适应这种开发模式的。比如有些人脑洞不够大，没法想象在没有实现代码的情况下，咋写测试。再比如，一些遗留代码并没有测试，而开发这代码的那个家伙已经离职了。再比如，你的队友是一个超级大牛，可以在脑中直接绘制整个系统的结构已经业务流程，甚至是所有的代码细节，所以人家不屑于写测试。而你写测试就拖慢了人家的工作。诸如此类，不胜枚举啊。然而，TDD 仍然是很好的开发实践。如果有机会去尝试，就一定要试一下，看看这个开发的方式是不是能给你带来意想不到的效果。


《测试驱动开发的艺术》已经草草的看完了，虽然我已经掌握了 TDD 的精髓（自我感觉良好），但是实践之路仍然漫长。当然，多读书也还是很好的，下一本是《测试驱动开发 by example 》，据说是一个牛人写的。当然所谓牛人不过是长得像牛罢了，反正重要的是内容和思想。谁写的不重要。

